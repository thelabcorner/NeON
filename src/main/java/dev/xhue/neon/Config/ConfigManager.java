package dev.xhue.neon.Config;

import dev.xhue.neon.NeON;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ConfigManager {
    private final File configFile;
    public FileConfiguration config;
    private final Logger logger = Logger.getLogger("NeON");

    public ConfigManager(File dataFolder, String fileName) {
        if (!dataFolder.exists()) {
            dataFolder.mkdirs();
        }
        this.configFile = new File(dataFolder, fileName);

        if (!configFile.exists() || configFile.length() == 0) {
            try {
                if (!configFile.exists()) {
                    configFile.createNewFile();
                }
                // Add initial comment to the config file
                List<String> header = new ArrayList<>();
                header.add("  ###################################");
                header.add("         ▐ ▄ ▄▄▄ .       ▐ ▄ ");
                header.add("        •█▌▐█▀▄.▀·▪     •█▌▐█");
                header.add("        ▐█▐▐▌▐▀▀▪▄ ▄█▀▄ ▐█▐▐▌");
                header.add("        ██▐█▌▐█▄▄▌▐█▌.▐▌██▐█▌");
                header.add("        ▀▀ █▪ ▀▀▀  ▀█▄▀▪▀▀ █▪ by xHue");
                header.add("  ###################################");
                header.add(" ");
                header.add("  Copyright (c) 2025 thelabcorner (xHue) ═ https://creativecommons.org/licenses/by-nc-sa/4.0/");
                header.add("  This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.");
                header.add("  You may use, modify and share this work for non-commercial purposes with attribution; all derivatives must use the same license.");
                header.add(" ");
                header.add("  ------");
                header.add("  Thanks for downloading NeON! This is your configuration file.");
                header.add(" ");
                header.add("  Indentation is EXTREMELY IMPORTANT in YAML files. Please ensure you maintain the generated layout.");
                header.add("  If you encounter issues, please first check the server console for errors.");
                header.add("  If that yields no immediate result, try putting your config file through YAML validator, like: https://www.yamllint.com/");
                header.add("  If all else fails, please open an issue on the GitHub repository: https://github.com/thelabcorner/NeON");
                header.add(" ");
                header.add("  ------");
                header.add("  NeON parses every string format value for NeON-specific + PlaceholderAPI placeholders, Legacy (&a-f,0-9) Color-Codes, and MiniMessage adventure formatting.");
                header.add("  This means you can use any of these formats in your strings, even as a mixture, and NeON will parse them for you.");
                header.add("  For example: \"<dark_gray>[&a+&8] <#FF00FF>%essentials_nickname%\"");
                header.add("  ");
                header.add("  NeON is compatible with most vanish plugins, but it's important to note that Essentials vanish is not supported. Use a plugin like SuperVanish or VanishNoPacket for best results.");
                header.add("  ");
                header.add("  NeON is dependant on PlaceholderAPI (https://www.spigotmc.org/resources/placeholderapi.6245/) you must have it installed for the placeholders to work.");
                header.add("  If you are installing PlaceholderAPI for the first time, be sure to download the 'Player', 'Server' and 'Essentials' expansions.");
                header.add("  You can install PlaceholderAPI expansions ingame using the command: /papi ecloud download <expansion>");
                header.add("  See here for a list of available expansions: https://wiki.placeholderapi.com/users/placeholder-list/");
                header.add("  ");
                header.add("  ------");
                header.add("  This file was automatically generated by NeON [v" + NeON.getPlugin().getDescription().getVersion() + "] on " + new Date());
                header.add("  ------");
                header.add("  If the generation version/date above is multiple versions behind, consider allowing NeON to regenerate this file.");
                header.add("  When updating NeON, this config file should automatically update with any new keys (preserving your existing config). However, in the event of a key being removed or changed, beware that this may cause issues.");
                header.add("  It's recommended to keep a backup of your config file before updating, just in case!");
                header.add(" ");
                header.add("  If you wish to have NeON generate a new configuration file, simply delete or rename the old file.");
                header.add("  In the event NeON detects an invalid configuration file, it will attempt to rename the old file and generate a new one. YML can be a nightmare!");
                header.add(" ");
                header.add("  ------");
                header.add("  If you want to support the development of NeON, please consider donating to me on Ko-fi: https://ko-fi.com/xhue");
                header.add(" ");

                config = YamlConfiguration.loadConfiguration(configFile);
                config.options().setHeader(header);
                saveConfig();

            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            this.config = YamlConfiguration.loadConfiguration(configFile);
        }
        reloadConfig(); // Use reloadConfig here to load initially
    }


    public boolean reloadConfig() {
        if (configFile == null) {
            System.out.println("[DEBUG] Cannot reload configuration: file path is not set.");
            return false;
        }
        if (!configFile.exists()) {
            System.out.println("[DEBUG] Cannot reload configuration: File not found at expected path: " + configFile.getPath() + ". The existing configuration in memory remains unchanged.");
            return false;
        }

        YamlConfiguration newConfig = new YamlConfiguration();
        try {
            newConfig.load(configFile);
            this.config = newConfig;
            System.out.println("[DEBUG] Successfully reloaded configuration from " + configFile.getPath());
            return true; // Indicate success
        } catch (FileNotFoundException e) {
            System.out.println("[ERROR] Config Reload failed: Configuration file disappeared unexpectedly: " + configFile.getPath());
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            System.out.println("[ERROR] Config Reload failed: Could not read configuration file: " + configFile.getPath());
            e.printStackTrace();
            return false;
        } catch (InvalidConfigurationException e) {
            System.out.println("[ERROR] Config Reload failed: Invalid configuration format: " + configFile.getPath());
            e.printStackTrace();
            handleInvalidConfigFile(e);
            return false;
        } catch (Exception e) {
            System.out.println("[ERROR] Config Reload failed: An unexpected error occurred while reloading the configuration: " + configFile.getPath());
            e.printStackTrace();
            return false;
        }
    }


    /**
     * Handles the situation where the configuration file on disk is invalid.
     * Renames the invalid file and attempts to save the current in-memory config.
     *
     * @param e The exception indicating the invalid configuration.
     */
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyyMMdd-HHmmss");

    private void handleInvalidConfigFile(InvalidConfigurationException e) {
        // Log the primary error
        logger.log(Level.SEVERE, "Config Reload failed: Invalid configuration format detected in file: " + configFile.getPath() + ". Attempting to backup invalid file and restore last known good configuration.", e);
        if (e.getCause() != null) {
            logger.log(Level.SEVERE, "Underlying cause: ", e.getCause());
        }

        // 1. Rename the invalid file
        String timestamp = DATE_FORMAT.format(new Date());
        String invalidFileName = configFile.getName() + "." + timestamp + ".INVALID";
        File invalidFile = new File(configFile.getParentFile(), invalidFileName);

        try {
            // Use Files.move for better error handling and atomic operation where possible
            Files.move(configFile.toPath(), invalidFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
            logger.info("Backed up invalid configuration file to: " + invalidFile.getPath());
        } catch (IOException moveEx) {
            logger.log(Level.SEVERE, "Failed to rename/backup the invalid configuration file: " + configFile.getPath() + " to " + invalidFile.getPath(), moveEx);
            // Decide if you should proceed with saving or stop here
            // For safety, maybe don't overwrite if backup failed?
            logger.warning("Aborting restore of last known good configuration because backup failed.");
            return; // Stop here if backup failed
        }

        // 2. Save the current in-memory config back to the original file path
        logger.info("Attempting to save the last known good configuration back to: " + configFile.getPath());
        saveConfig(); // Call the separate save method
    }


    // Get a configuration value
    public Object get(String key) {
        reloadConfig(); // Reload from disk before getting the value
        return config.get(key);
    }

    // Set a configuration value (adds or updates)
    public void set(String key, Object value) {
        config.set(key, value);
        saveConfig();
    }

    public void addIfAbsent(String key, Object value, String comment) {
        List<String> commentLines = null;
        if (comment != null && !comment.isBlank()) {
            commentLines = new ArrayList<>();
            commentLines.addAll(Arrays.asList(comment.split("\r?\n")));
        }
        addIfAbsentInternal(key, value, commentLines);
    }

    public void addIfAbsent(String key, Object value, List<String> comment) {
        addIfAbsentInternal(key, value, comment);
    }

    private void addIfAbsentInternal(String key, Object value, List<String> commentLines) {
        if (!config.contains(key)) {
            logger.info("[DEBUG] Key '" + key + "' is absent. Adding value: " + value);

            // Backup comments for all existing keys
            Map<String, List<String>> existingComments = new HashMap<>();
            for (String existingKey : config.getKeys(true)) {
                List<String> lines = config.getComments(existingKey);
                if (lines != null && !lines.isEmpty()) {
                    existingComments.put(existingKey, new ArrayList<>(lines));
                }
            }

            // Add the new key/value
            config.set(key, value);

            // Apply comment to the new key if provided
            if (commentLines != null && !commentLines.isEmpty()) {
                logger.info("[DEBUG] Adding comment to key: " + key);
                List<String> formattedComment = new ArrayList<>();
                formattedComment.add(" ");
                formattedComment.add(" ════════════════════════════════════════════════════════════════════════════════════");
                for (String line : commentLines) {
                    formattedComment.add(" " + line);
                }
                formattedComment.add(" ════════════════════════════════════════════════════════════════════════════════════");
                config.setComments(key, formattedComment);
            }

            // Restore comments on other keys
            for (Map.Entry<String, List<String>> entry : existingComments.entrySet()) {
                String existingKey = entry.getKey();
                if (!existingKey.equals(key)) {
                    config.setComments(existingKey, entry.getValue());
                }
            }

            // Save once with everything in place
            saveConfig();
        } else {
            logger.info("[DEBUG] Key '" + key + "' already exists. Skipping addition.");
        }
    }

    // Remove a configuration value
    public void remove(String key) {
        config.set(key, null);
        saveConfig();
    }

    // Save configuration to file
    public void saveConfig() {
        try {
            config.save(configFile);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
